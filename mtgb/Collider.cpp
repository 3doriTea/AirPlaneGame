#include "Collider.h"
#include "Transform.h"
#include "DirectXMath.h"
#include "Matrix4x4.h"

mtgb::Collider::Collider(const EntityId _entityId) :
	IComponent{ _entityId },
	pTransform_{ &Transform::Get(_entityId) }
{
}

mtgb::Collider::~Collider()
{
}

bool mtgb::Collider::IsHit(const Collider& _other) const
{
	using DirectX::XMVector3TransformCoord;

	static Matrix4x4 matrix{};
	if (type_ == _other.type_)
	{
		if (type_ == TYPE_SPHERE)
		{
			pTransform_->GenerateWorldMatrix(&matrix);
			Vector3 worldPosition{ pTransform_->position_ * matrix };

			_other.pTransform_->GenerateWorldMatrix(&matrix);
			Vector3 otherWorldPosition{ pTransform_->position_ * matrix };

			float distance{ (otherWorldPosition - worldPosition).Size() };
			float hitDistance{ sphere_.radius_ + _other.sphere_.radius_ };

			// 距離が双方の球の半径よりも小さければ当たっている
			return (distance <= hitDistance);
		}
		else if (type_ == TYPE_CAPSULE)
		{
			// TODO: カプセル同士の当たり判定
		}
	}
	else
	{
		if (type_ == TYPE_SPHERE)
		{
			// TODO: 球と球の当たり判定
		}
		else if (type_ == TYPE_CAPSULE)
		{
			// TODO: カプセルと球の当たり判定
		}
	}

	return false;
}
